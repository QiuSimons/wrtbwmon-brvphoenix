#!/bin/sh
#

# Default input parameters for wrtbwmon.
runMode=0
Monitor46=4

# Some parameters for monitor process.
updatePID=
logFile=/var/log/wrtbwmon.log
lockFile=/var/lock/wrtbwmon.lock
pidFile=/var/run/wrtbwmon.pid

# Debug parameters for readDB.awk.
mode=
DEBUG=

# Constant parameter for wrtbwmon.
binDir=/usr/sbin
dataDir=/usr/share/wrtbwmon

networkFuncs=/lib/functions/network.sh
uci=`which uci 2>/dev/null`
nslookup=`which nslookup 2>/dev/null`
nvram=`which nvram 2>/dev/null`

chains='INPUT OUTPUT FORWARD'
interfaces='eth0 tun0' # in addition to detected WAN

# DNS server for reverse lookups provided in "DNS".
# don't perform reverse DNS lookups by default
DO_RDNS=${DNS-}

header="#mac,ip,iface,in,out,total,first_date,last_date"

createDbIfMissing()
{
	[ ! -f "$DB" ] && echo $header > "$DB"
	[ ! -f "$DB6" ] && echo $header > "$DB6"
}

checkDbArg()
{
	[ -z "$DB" ] && echo "ERROR: Missing argument 2 (database file)" && exit 1
}

checkDB()
{
	[ ! -f "$DB" ] && echo "ERROR: $DB does not exist" && exit 1
	[ ! -w "$DB" ] && echo "ERROR: $DB is not writable" && exit 1
	[ ! -f "$DB6" ] && echo "ERROR: $DB6 does not exist" && exit 1
	[ ! -w "$DB6" ] && echo "ERROR: $DB6 is not writable" && exit 1
}

checkWAN()
{
	[ -z "$wan" ] && echo "Warning: failed to detect WAN interface."
}

lookup()
{
	local MAC=$1
	local IP=$2
	local userDB=$3
	local USERSFILE=
	local USER=
	for USERSFILE in $userDB /tmp/dhcp.leases /tmp/dnsmasq.conf /etc/dnsmasq.conf /etc/hosts; do
		[ -e "$USERSFILE" ] || continue

		case $USERSFILE in
			/tmp/dhcp.leases )
			USER=$(grep -i "$MAC" $USERSFILE | cut -f4 -s -d' ')
			;;
			/etc/hosts )
			USER=$(grep "^$IP " $USERSFILE | cut -f2 -s -d' ')
			;;
			* )
			USER=$(grep -i "$MAC" "$USERSFILE" | cut -f2 -s -d,)
			;;
		esac

		[ "$USER" = "*" ] && USER=
		[ -n "$USER" ] && break

	done

	if [ -n "$DO_RDNS" -a -z "$USER" -a "$IP" != "NA" -a -n "$nslookup" ]; then
		USER=`$nslookup $IP $DNS | awk '!/server can/{if($4){print $4; exit}}' | sed -re 's/[.]$//'`
	fi

	[ -z "$USER" ] && USER=${MAC}
	echo $USER
}

detectIF()
{
	local IF=
	if [ -f "$networkFuncs" ]; then
		IF=`. $networkFuncs; network_get_device netdev $1; echo $netdev`
		[ -n "$IF" ] && echo $IF && return
	fi

	if [ -n "$uci" -a -x "$uci" ]; then
		IF=`$uci get network.${1}.ifname 2>/dev/null`
		[ $? -eq 0 -a -n "$IF" ] && echo $IF && return
	fi

	if [ -n "$nvram" -a -x "$nvram" ]; then
		IF=`$nvram get ${1}_ifname 2>/dev/null`
		[ $? -eq 0 -a -n "$IF" ] && echo $IF && return
	fi
}

detectLAN()
{
	[ -e /sys/class/net/br-lan ] && echo br-lan && return
	local lan=$(detectIF lan)
	[ -n "$lan" ] && echo $lan && return
}

detectWAN()
{
	local wan=$(detectIF wan)
	[ -n "$wan" ] && echo $wan && return
	wan=$(ip route show 2>/dev/null | grep default | sed -re '/^default/ s/default.*dev +([^ ]+).*/\1/')
	[ -n "$wan" ] && echo $wan && return
	[ -f "$networkFuncs" ] && wan=$(. $networkFuncs; network_find_wan wan; echo $wan)
	[ -n "$wan" ] && echo $wan && return
}

lockFunc()
{
	#Realize the lock function by busybox lock or flock command.
	#	if !(lock -n $lockFile) >/dev/null 2>&1; then
	#		exit 1
	#	fi
	#	trap "rm -f /tmp/*_${updatePID}.tmp; kill -9 ${updatePID}; rm -f $lockFile" INT KILL TERM EXIT
	#The following lock method is realized by other's function.

	local attempts=0
	local flag=0

	while [ "$flag" = 0 ]; do
		local tempfile=$(mktemp /tmp/lock.XXXXXX)
		ln $tempfile $lockFile >/dev/null 2>&1 && flag=1
		rm $tempfile

		if [ "$flag" = 1 ]; then
			[ -n "$DEBUG" ] && echo ${updatePID} "got lock after $attempts attempts"
			flag=1
		else
			sleep 1
			attempts=$(($attempts+1))
			[ -n "$DEBUG" ] && echo ${updatePID} "The $attempts attempts."
			[ "$attempts" -ge 10 ] && exit
		fi
	done
	trap "" INT
}

unlockFunc()
{
	#Realize the lock function by busybox lock or flock command.
	#	lock -u $lockFile
	#	rm -f $lockFile
	#	rm -f /tmp/*_${updatePID}.tmp
	#	[ -n "$DEBUG" ] && echo ${updatePID} "released lock"
	#	trap "" INT KILL TERM EXIT
	#The following lock method is realized by other's function.

	rm -f $lockFile
	rm -f /tmp/*_${updatePID}.tmp
	[ -n "$DEBUG" ] && echo ${updatePID} "released lock"
	trap - INT
}

# chain
newChain()
{
	local chain=$1
	local ipt=$2
	# Create the RRDIPT_$chain chain (it doesn't matter if it already exists).

	$ipt -t mangle -N RRDIPT_$chain 2> /dev/null

	# Add the RRDIPT_$chain CHAIN to the $chain chain if not present
	$ipt -t mangle -C $chain -j RRDIPT_$chain 2>/dev/null
	if [ $? -ne 0 ]; then
		[ -n "$DEBUG" ] && echo "DEBUG: $ipt chain misplaced, recreating it..."
		$ipt -t mangle -I $chain -j RRDIPT_$chain
	fi
}

# chain tun
newRuleIF()
{
	local chain=$1
	local IF=$2
	local ipt=$3
	local cmd=

	#!@todo test
	if [ "$chain" = "OUTPUT" ]; then
		cmd="$ipt -t mangle -o $IF -j RETURN"
		eval $cmd " -C RRDIPT_$chain 2>/dev/null" || eval $cmd " -A RRDIPT_$chain"
	elif [ "$chain" = "INPUT" ]; then
		cmd="$ipt -t mangle -i $IF -j RETURN"
		eval $cmd " -C RRDIPT_$chain 2>/dev/null" || eval $cmd " -A RRDIPT_$chain"
	fi
}

publish()
{
	trap 'rm -f $lockFile; rm -f /tmp/*_${updatePID}.tmp; rm -f ${pb_html}.tmp; ending' TERM

	# sort DB
	# busybox sort truncates numbers to 32 bits
	grep -v '^#' $DB | awk -F, '{OFS=","; a=sprintf("%f",$4/1e6); $4=""; print a,$0}' | tr -s ',' | sort -rn | awk -F, '{OFS=",";$1=sprintf("%f",$1*1e6);print}' > /tmp/sorted_${updatePID}.tmp

	# create HTML page
	rm -f ${pb_html}.tmp
	cp $dataDir/usage.htm1 ${pb_html}.tmp

	#!@todo fix publishing
	while IFS=, read PEAKUSAGE_IN MAC IP IFACE PEAKUSAGE_OUT TOTAL FIRSTSEEN LASTSEEN
	do
		echo "
new Array(\"$(lookup $MAC $IP $user_def)\",\"$MAC\",\"$IP\",
$PEAKUSAGE_IN,$PEAKUSAGE_OUT,$TOTAL,\"$FIRSTSEEN\",\"$LASTSEEN\")," >> ${pb_html}.tmp
	done < /tmp/sorted_${updatePID}.tmp
	echo "0);" >> ${pb_html}.tmp

	sed "s/(date)/`date`/" < $dataDir/usage.htm2 >> ${pb_html}.tmp
	mv ${pb_html}.tmp "$pb_html"
}

updatePrepare() {
	local timeNow=$(cat /proc/uptime | awk '{print $1}')
	local timeLast=0
	if [ -e "$logFile" ]; then
		timeLast=$(awk -F, '{print $1}' "$logFile")
		interval=$(awk -v now=$timeNow -v last=$timeLast 'BEGIN{print (now-last)}')
		echo $interval

		if [[ $interval \> 0.2 ]]; then
			echo $timeNow >"$logFile"
			return 0
		else
			return 1
		fi
	else
		echo $timeNow >"$logFile"
		return 0
	fi
}

update()
{
	trap 'rm -f $lockFile; rm -f /tmp/*_${updatePID}.tmp; ending' TERM

	#!@todo could let readDB.awk handle this; that would place header
	#!info in fewer places
	updatePID=$( sh -c 'echo $PPID' )

	lockFunc

	checkDbArg
	wan=$(detectWAN)
	checkWAN

	interfaces="$interfaces $wan"

	createDbIfMissing
	checkDB

	[ "$Monitor46" = 4 ] && IPT='iptables'
	[ "$Monitor46" = 6 ] && IPT='ip6tables'
	[ "$Monitor46" = 46 ] && IPT='iptables ip6tables'

	for ii in $IPT ; do
		if [ -z "$( ${ii}-save | grep RRDIPT )" ]; then

			for chain in $chains; do
				newChain $chain $ii
			done

			# track local data
			for chain in INPUT OUTPUT; do
				for interface in $interfaces; do
				[ -n "$interface" ] && [ -e "/sys/class/net/$interface" ] && newRuleIF $chain $interface $ii
				done
			done
		fi
		# this will add rules for hosts in arp table
		> /tmp/${ii}_${updatePID}.tmp

		for chain in $chains; do
			$ii -nvxL RRDIPT_$chain -t mangle -Z >> /tmp/${ii}_${updatePID}.tmp
		done
	done

	[ -f /tmp/iptables_${updatePID}.tmp ] && (
		ipReg=`uci get network.lan.ipaddr | grep -o -e '\([0-9]\+\.\)\{2\}[0-9]\+'`;
		awk -v mode="$mode" -v interfaces="$interfaces" -v ipReg="$ipReg" -v wanIF="$wan" \
		-v ipv6="0" -f $binDir/readDB.awk \
		$DB \
		/proc/net/arp \
		/tmp/iptables_${updatePID}.tmp
	)

	[ -f /tmp/ip6tables_${updatePID}.tmp ] && (
		echo "This file is geneated by 'ip -6 neigh'" >/tmp/ip6addr_${updatePID}.tmp
		`ip -6 neigh >>/tmp/ip6addr_${updatePID}.tmp`;
		ipReg=`ip -6 route | grep default | awk '{print $3}' | awk -F: '{print $1}'`;

		awk -v mode="$mode" -v interfaces="$interfaces" -v ipReg="$ipReg" -v wanIF="$wan" \
		-v ipv6="1" -f $binDir/readDB.awk \
		"$DB6" \
		/tmp/ip6addr_${updatePID}.tmp \
		/tmp/ip6tables_${updatePID}.tmp
	)

	[ "$Monitor46" = 46 ] && (
		cp $DB $DB46
		cat $DB6 >> $DB46
		awk -f $binDir/readDB.awk "$DB46"
	)

	# the iptables and readDB commands have to be separate. Otherwise,
	# they will fight over iptables locks

	[ -n "$pb_html" ] && publish

	unlockFunc
}

ending()
{
	iptables-save | grep -v RRDIPT | iptables-restore
	ip6tables-save | grep -v RRDIPT | ip6tables-restore

	if [ -e "$pidFile" ]; then
		local pid=$( cat "$pidFile" )
		kill -9 $pid >> /dev/null 2>&1
	fi

	rm -f "$pidFile" >> /dev/null 2>&1
	echo "exit!!"
}

loop()
{
	if [ -e "$pidFile" ]; then
		echo "Another wrtbwmon is on running!!!"
	else
		sh -c 'echo $PPID > $pidFile' && :
		while true ;do
			updatePrepare && update
			sleep 1m
		done
	fi
}

tips()
{
	echo \
"Usage: $0 [options...]
Options:
   -k 			Exit the wrtbwmon!
   -f dbfile	Set the DB file path
   -u usrfile	Set the user_def file path
   -p htmlfile	Set the publish htm file path
   -d			Enter the foreground mode.
   -D			Enter the daemo mode.
   -4			Listen to ipv4 only.
   -6			Listen to ipv6 only.
   -46			Listen to ipv4 and ipv6.

Note: [user_file] is an optional file to match users with MAC addresses.
	   Its format is \"00:MA:CA:DD:RE:SS,username\", with one entry per line."
}

############################################################

while [ $# != 0 ];do
	case $1 in
		"-k" )
			ending
			exit 0
		;;
		"-f" )
			shift
			if [ $# -gt 0 ];then
				DB=$1
				DB6=$( echo "${DB%.*}.6.${DB##*.}" )
				DB46=$( echo "${DB%.*}.46.${DB##*.}" )
			else
				echo "No db file path seted, exit!!"
				exit 1
			fi
		;;
		"-u")
			shift
			if [ $# -gt 0 ];then
				user_def=$1
			else
				echo "No user define file path seted, exit!!"
				exit 1
			fi
		;;

		"-p")
			shift
			if [ $# -gt 0 ];then
				pb_html=$1
			else
				echo "No publish html file path seted, exit!!"
				exit 1
			fi
		;;

		"-d")
			runMode=1
		;;

		"-D")
			runMode=2
		;;

		"-4")
			Monitor46=4
		;;

		"-6")
			Monitor46=6
		;;

		"-46")
			Monitor46=46
		;;

		"&&" | "||" | ";")
			break
		;;

		"*")
			tips
		;;
	esac

	shift
done

if [ "$runMode" = '1' ]; then
	loop
elif [ "$runMode" = '2' ]; then
	loop >>/dev/null 2>&1 &
else
	updatePrepare && update
fi
